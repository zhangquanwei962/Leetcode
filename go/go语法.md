- `sort.Sort(sort.Reverse(sort.IntSlice(reward1)))` 从大到小进行排序

- `'9'`的ascii码是57

- `sort.Search(n, func()bool{})`是一个搜索的

- `(x+y-1)/y`是向上取整 或者是 `int(math.Ceil(float64(pile) / float64(mid)))` 这两个都可以做到

- `strings.Contains("aeiou", w[:1])`就是查找在不在

- `strings.Tolower`

- `strings.ContainsRune("aeiou", ch)`这个就是一个go的api，查找ContainsRune

- `FieldsFunc` 是 Go 语言标准库中 strings 包提供的一个函数，用于将一个字符串按照特定的分隔符进行分割，并返回分割后的每一段子字符串组成的切片。`func FieldsFunc(s string, f func(rune) bool) []string`

- 有负数的循环表 `((cur+nums[cur])%n + n) % n` // 保证返回值在 [0,n) 中

- 对于`A-Z`的映射，1-26映射到，应该是`(col-1)%26, col=(col-1)/26`，避免出现问题，而不是-1~25的映射

- KMP,要想做到深拷贝，只能**copy**

## Dijkstra和0-1BFS只保证第一次出队是最小的

## 最大公约数和最小公倍数

最小公倍数和最大公约数是两个常见的数学概念，它们之间存在着一定的关系。

最大公约数指的是两个或多个整数之间最大的公约数，即同时整除它们的最大正整数。而最小公倍数则是指两个或多个整数所共同拥有的最小倍数，即是这些数的一个公倍数并且是它们所有公倍数中最小的一个。

可以通过以下公式来计算最小公倍数和最大公约数：

若 a 和 b 是两个正整数，则有：

最大公约数：`gcd(a, b) * lcm(a, b) = a * b`

最小公倍数：`lcm(a, b) = a * b / gcd(a, b)`

其中，`gcd(a, b)` 是 `a `和 `b` 的最大公约数，`lcm(a, b)` 是 a 和 b 的最小公倍数。

也就是说，最大公约数和最小公倍数互为倒数。在实际应用中，我们通常可以通过先计算最大公约数再使用上述公式来计算最小公倍数。
# 总结

- 对于有两个变量的题目，通常可以枚举其中一个变量，把它视为常量，从而转化成只有一个变量的问题，在第一题就有用到


## go的GC

在 Go 语言中，GC（Garbage Collection，垃圾回收）是一种自动内存管理机制，用于回收不再使用的内存空间，从而避免内存泄漏和程序崩溃等问题。

Go 的 GC 实现是基于三色标记（tri-color marking）算法的，并且采用了并发清除（concurrent sweep）的方式，即 GC 进程可以和应用程序并发执行。这样可以确保 GC 对应用程序的干扰尽可能小，同时也保证了 GC 在清除内存空间时的效率和准确性。

在 Go 中，GC 主要分为两个阶段：标记（mark）阶段和清除（sweep）阶段。

在标记阶段，GC 扫描堆内存中的对象，并标记那些仍然在使用中的对象。这个过程使用三色标记法，把对象分成白色、黑色和灰色三类。黑色表示已经扫描过的对象，灰色表示正在被扫描的对象，白色表示未被扫描的对象。GC 遍历根对象和它们引用的对象，标记为灰色，然后遍历灰色对象引用的对象，标记为灰色或黑色。重复这个过程，直到灰色队列为空，所有存活的对象都被标记为黑色。

在清除阶段，GC 清除所有未标记的白色对象，并回收它们所占用的内存空间。同时，GC 还会将被清除对象所占用的内存池释放给操作系统，以便其他应用程序使用。

值得一提的是，在 Go 1.5 版本之后，Go 的 GC 实现还支持并发标记（concurrent marking）和方式并行清除（parallel sweep），这样可以在避免阻塞程序运行的同时，大幅度提高 GC 的效率。

## Go性能调优

在 Go 程序中进行性能调优可以提高程序的整体运行效率和响应速度。以下是一些 Go 性能调优的建议：

1. 使用性能分析工具：Go 提供了内置的性能分析工具，包括 pprof 和 trace。pprof 可以分析 CPU 和内存的使用情况，找出程序瓶颈所在；trace 则可以分析 goroutine 的执行情况，了解系统性能瓶颈的原因，从而针对性地进行优化。

2. 避免重复计算：如果一个变量的值不会发生变化，可以将它的计算结果保存起来并重复使用，以减少重复计算的开销。另外，在循环中避免多次计算相同的表达式也可以提高程序的性能。

3. 避免频繁的内存分配：频繁的内存分配和回收会导致垃圾回收器的频繁触发，从而影响程序的性能。可以使用对象池或者预分配一定数量的空间来避免这种情况。

4. 使用并发编程：Go 有非常好的并发处理能力。使用 goroutine 和 channels 可以将任务分解成小块并行执行，提高程序的并发性和运行效率。

5. 优化代码逻辑：合理的代码逻辑可以减少计算量和操作次数，从而提高程序的性能。例如，使用位运算取代算术运算可以有效提升运算速度。

6. 使用高效的数据结构：在选择数据结构时应该根据具体情况选择最适合的数据结构。例如，使用 map 可以快速查找数据，但是占用内存较大；而数组访问速度较快，但是插入和删除操作慢。

7. 避免过分优化：过度优化代码不仅会降低程序的可读性和可维护性，还可能带来一些无法预料的问题。应该根据实际情况选择最适合的优化方案，并在保持代码简洁易读的基础上进行优化。

总之，Go 的性能调优需要结合具体情况进行，需要考虑代码逻辑、数据结构、并发处理等多个方面。通过合理选择优化方案，可以提高程序的性能，进而满足实际需求。


# go的协程线程之间的关系

在 Go 语言中，协程（Goroutine）是一种轻量级线程实现机制。它可以与操作系统的线程（Thread）一起使用，但是一个操作系统线程可以运行多个Go语言协程。

在 Go 语言中，协程之间可以通过通道（Channel）进行通信，通道是一种特殊的类型，允许协程在彼此之间传递数据。协程通过发送和接收数据来与通道进行交互，这会导致协程阻塞或者解除阻塞。

通道是 Go 语言的关键抽象，它使得协程之间的同步和通信变得非常简单。通过通道，协程可以安全地共享数据和状态，而不必担心竞态条件和锁问题。

此外，Go 语言还提供了其他一些机制来控制协程的执行，例如 sync 包中的 Mutex、RWMutex 和 WaitGroup 类型等。这些同步原语可以帮助您编写更加复杂的并发程序，以及避免一些可能导致死锁的情况。

总之，在 Go 语言中，协程之间的关系是通过通道和同步原语来实现的。这使得编写高效且安全的并发程序变得非常容易，同时也使得Go语言成为了一个非常强大的并发编程语言。

# go中的锁原理，go中如何保证goroutine间并发安全

在 Go 语言中，锁是一种用于保护共享资源的同步机制。每个操作共享资源的协程在访问共享数据之前必须先获得锁，在操作完成后再释放锁。这种操作方式可以确保并发访问的安全性。

Go 语言提供了两种类型的锁：Mutex 和 RWMutex。其中 Mutex 是最基本的锁，只支持两个方法：Lock 和 Unlock。协程想要访问被锁保护的共享资源时，必须先调用 Lock 方法来获取锁，访问完后再调用 Unlock 方法释放锁，以便其他协程可以获得锁并访问共享资源。

RWMutex 是相对于 Mutex 更高级的锁机制。它能够同时支持读取锁定和写入锁定。多个协程可以同时获得读取锁定，而只有一个协程可以获得写入锁定。读取锁定和写入锁定之间是互斥的，所以在协程想要进行写入时，必须等待所有读取锁定被释放。这可以有效的避免数据不一致和竞态问题。

除了锁，Go 语言还提供了一些其他的机制来保证并发安全，例如通道（Channel），原子操作和 WaitGroup 等。当协程通过通道进行交互时，通道作为一个同步机制，可以确保协程之间的同步和顺序性，从而防止竞态问题，并保证并发访问的安全。

总之，Go 语言通过锁、通道、原子操作和 WaitGroup 等机制来确保协程之间的并发安全。在编写并发程序时，我们应该遵循这些机制，用最小的代价实现最大的并发效率。